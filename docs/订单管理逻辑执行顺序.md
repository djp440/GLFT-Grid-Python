# 订单管理逻辑执行顺序

本文档详细描述了TradeManager中订单管理系统的完整执行流程，按照实际执行顺序排列。

## 1. 系统初始化阶段

### 1.1 TradeManager初始化 (`__init__`)
- 设置交易对名称、交易所连接
- 配置价差参数：baseSpread、minSpread、maxSpread
- 设置订单冷却时间、最大持仓比例
- 初始化各种状态变量和锁机制

### 1.2 交易对信息初始化 (`initSymbolInfo`)
1. **获取账户余额**
   - 调用 `fetchBalance()` 获取USDT余额
   - 更新 `self.balance`

2. **加载市场信息**
   - 调用 `loadMarkets()` 获取交易对规则
   - 设置最小订单数量、价格精度、数量精度
   - 计算小数位数用于订单格式化

3. **获取当前价格**
   - 调用 `fetchTicker()` 获取最新价格
   - 更新 `self.lastPrice`

4. **初始化未成交订单**
   - 调用 `fetchOpenOrders()` 获取现有订单
   - 过滤出当前交易对的订单
   - 更新 `self.openOrders`

5. **初始化持仓信息**
   - 调用 `fetchPositions()` 获取持仓
   - 调用 `updatePosition()` 更新持仓状态

### 1.3 绑定WebSocket管理器 (`bindWebsocketManager`)
- 建立与WebSocket管理器的连接
- 用于后续订单监听功能

## 2. 主要交易流程

### 2.1 交易执行入口 (`runTrade`)
1. **检查当前订单状态**
   - 调用 `tradeUtil.checkOpenOrder()` 检查是否已有完整的买卖单对
   - 如果已有1个买单和1个卖单，跳过挂单流程

2. **清理现有订单**
   - 如果订单数量不符合要求（不是2个或不是1买1卖）
   - 调用 `cancelAllOrder()` 取消所有订单

3. **计算新订单价格**
   - 调用 `calculateOrderPrice()` 计算买卖价格

4. **执行下单操作**
   - 创建买单：`placeOrder(amount, buyPrice, "buy", False)`
   - 根据持仓情况决定是否创建卖单：
     - 如果有持仓 (`nowStockRadio != 0`)：创建卖单 `placeOrder(amount, sellPrice, "sell", True)`
     - 如果无持仓：只创建买单

5. **启动订单监听**
   - 如果下单成功且WebSocket管理器可用
   - 调用 `websocketManager.runOpenOrderWatch()` 开始监听订单成交

### 2.2 价格计算逻辑 (`calculateOrderPrice`)
1. **计算持仓比例**
   - `ratio = nowStockRadio / maxStockRadio`

2. **动态调整价差**
   - 平衡点设为0.5
   - **买单价差调整**：
     - ratio < 0.5时：从minSpread线性增长到baseSpread
     - ratio >= 0.5时：从baseSpread线性增长到maxSpread
   - **卖单价差调整**：
     - ratio < 0.5时：从maxSpread线性减少到baseSpread
     - ratio >= 0.5时：从baseSpread线性减少到minSpread

3. **价差边界检查**
   - 确保买卖价差都在minSpread和maxSpread范围内

4. **计算最终价格**
   - 买价：`lastPrice * (1 - buySpread)`
   - 卖价：`lastPrice * (1 + sellSpread)`

### 2.3 订单下单逻辑 (`placeOrder`)
1. **参数格式化**
   - 根据精度要求四舍五入数量和价格
   - 检查最小订单数量限制

2. **执行下单**
   - 调用交易所API：`createOrder(symbol, "limit", side, amount, price, {"reduceOnly": reduceOnly})`
   - 记录下单结果和订单信息

3. **更新状态**
   - 如果是买单，更新 `lastBuyPrice = lastPrice`

## 3. 订单成交处理流程

### 3.1 订单成交回调 (`onOrderFilled`)
1. **更新订单状态**
   - 调用 `fetchOpenOrders()` 获取最新订单列表
   - 调用 `updateOrders()` 更新本地订单状态

2. **更新持仓信息**
   - 调用 `fetchPositions()` 获取最新持仓
   - 调用 `updatePosition()` 更新持仓比例

3. **更新余额信息**
   - 调用 `fetchBalance()` 获取最新余额
   - 调用 `updateBalance()` 更新本地余额

4. **冷却等待**
   - 等待 `orderCoolDown` 时间，避免频繁操作

5. **重新执行交易**
   - 调用 `runTrade()` 重新挂单

## 4. 状态更新机制

### 4.1 价格更新 (`updateLastPrice`)
1. **更新最新价格**
   - 比较并更新 `lastPrice`

2. **触发重新挂单条件**
   - 无持仓且价格超过最后买单价的一定范围时
   - 条件：`positionSize == 0 && lastPrice > lastBuyPrice * (1 + baseSpread)`
   - 触发：调用 `runTrade()` 重新挂单

### 4.2 持仓更新 (`updatePosition`)
1. **计算持仓比例**
   - `marginSize = positionMarginSize(position, symbolName)`
   - `ratio = marginSize / (balance + marginSize)`

2. **更新持仓比例**
   - 如果比例发生变化，更新 `nowStockRadio`
   - 记录持仓比例变化日志

### 4.3 订单更新 (`updateOrders`)
1. **线程安全保护**
   - 使用 `_update_lock` 确保更新操作的原子性

2. **记录历史订单**
   - 保存旧订单信息用于对比

3. **更新订单列表**
   - 更新 `openOrders` 列表
   - 调用 `tradeUtil.checkOpenOrder()` 检查订单完整性

## 5. 异常处理和恢复机制

### 5.1 网络异常处理 (`networkHelper`)
1. **错误状态管理**
   - 设置 `networkError = True` 防止重复处理

2. **重试循环**
   - 持续尝试调用 `runTrade()` 恢复交易
   - 失败时等待5秒后重试

3. **恢复确认**
   - 成功执行后设置 `networkError = False`

### 5.2 订单取消机制 (`cancelAllOrder`)
1. **批量取消**
   - 调用 `cancelAllOrders(symbolName)` 取消所有订单

2. **结果确认**
   - 记录取消操作的成功或失败状态

## 6. 辅助功能

### 6.1 REST API备用方法
- `getAllOrdersREST()`：使用REST获取订单信息
- `updatePriceREST()`：使用REST获取价格信息
- `updatePositionREST()`：使用REST获取持仓信息

### 6.2 参数更新方法
- `updateBalance()`：更新余额
- `updateOrderAmount()`：更新订单数量
- `calculateOrderAmount()`：计算订单数量（待实现）

## 执行流程总结

```
初始化 → 绑定WebSocket → 主交易循环
   ↓
检查订单状态 → 清理订单 → 计算价格 → 下单 → 启动监听
   ↓
等待成交 → 订单成交回调 → 更新状态 → 冷却等待 → 重新交易
   ↓
异常处理 → 网络重连 → 恢复交易
```

整个系统通过事件驱动的方式运行，确保在订单成交后能够及时响应并重新挂单，实现连续的网格交易策略。